<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<title>Om: Language</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
		<link href="doxygen.css" rel="stylesheet" type="text/css"/>
		<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
		<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
			<div id="titlearea">
				<table cellspacing="0" cellpadding="0">
					<tbody>
						<tr style="height: 56px;">
							<td id="projectlogo"><img alt="Logo" src="om_small.png"/></td>
							<td style="padding-left: 0.5em;">
								<div id="projectname">Om
								</div>
								<div id="projectbrief">A Simple Programming Language</div>
							</td>
						</tr>
					</tbody>
				</table>
			</div>
			<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('language__.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Language </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="language__syntax__"></a>
Syntax</h1>
<p>An Om program is a combination of three elements&mdash;operator, separator, and operand&mdash;as follows:</p>
<div class="image">
<img src="program.png" alt="program.png"/>
</div>
<h2><a class="anchor" id="language__syntax__operator__"></a>
Operator</h2>
<p>An operator has the following syntax:</p>
<div class="image">
<img src="operator.png" alt="operator.png"/>
</div>
<p>Backquotes (<code>`</code>) in operators are disregarded if the code point following is not a backquote, operand brace, or separator code point.</p>
<h2><a class="anchor" id="language__syntax__separator__"></a>
Separator</h2>
<p>A separator has the following syntax:</p>
<div class="image">
<img src="separator.png" alt="separator.png"/>
</div>
<h2><a class="anchor" id="language__syntax__operand__"></a>
Operand</h2>
<p>An operand has the following syntax:</p>
<div class="image">
<img src="operand.png" alt="operand.png"/>
</div>
<h1><a class="anchor" id="language__functions__"></a>
Functions</h1>
<p>Om is a <a href="http://concatenative.org">concatenative</a> language, whereby each Om program evaluates to a function (that takes a program as input, and returns a program as output) and the concatenation of two programs (with an intervening separator, as necessary) evaluates to the composition of the corresponding functions.</p>
<h2><a class="anchor" id="language__functions__prefix__"></a>
Prefix Notation</h2>
<p>Unlike other concatenative languages, Om uses <a href="http://en.wikipedia.org/wiki/Polish_notation">prefix notation</a>. A function takes the remainder of the program as input and returns a program as output (which gets passed as input to the leftward function).</p>
<p>Prefix notation has the following advantages over postfix notation:</p>
<ul>
<li>Stack underflows are impossible.</li>
<li>Prefix notation more closely models function composition. Instead of storing a data stack in memory, the Om evaluator stores a composed partial function.</li>
<li>The evaluator can read, parse and evaluate the input stream in a single pass, sending results to the output stream as soon as they are evaluated. This cannot be done with a postfix, stack-based language because any data on the stack must remain there as it may be needed by a function later.</li>
<li>Functions can be optimized to only read into memory the data that is required; stack-based postfix languages have no knowledge of the function to apply until the data is already in memory, on the stack.</li>
<li>Incoming data, such as events, become simple to handle at a language level: a program might evaluate to a function that acts as a state machine that processes any additional data appended to the program and transitions to a new state, ready to process new data.</li>
<li>An integrated development environment can provide hints to the user about the data that is expected by a function.</li>
</ul>
<h2><a class="anchor" id="language__functions__evaluation__"></a>
Evaluation</h2>
<p>Only the <em>terms</em> (operators and operands) of a program are significant to functions: separators are discarded from input, and are inserted between output terms in a "normalized" form (for consistent formatting and proper operator separation).</p>
<p>There are three fundamental types of functions:</p>
<ul>
<li><b>Identity:</b> A function whose output program contains all the terms in the input program.</li>
<li><b>Constant:</b> A function whose output program contains a term, defined by the function, followed by all terms in the input program.</li>
<li><b>Operation:</b> A function that is named by an operator and defines a computation. An operation processes operands at the front of the input program as data for the computation, and pushes any terms generated by the computation onto the output program, until one of two things happens:<ul>
<li>If the computation is completed, the rest of the input terms are pushed onto the output program.</li>
<li>If the computation cannot be completed (due to insufficient operands), the operator that names the operation is pushed onto the output program, followed by all remaining input terms.</li>
</ul>
</li>
</ul>
<p>Programs are evaluated as functions in the following way:</p>
<ul>
<li>The <b>empty program</b> evaluates to the identity function.</li>
<li>Programs that contain only a <b>single element</b> evaluate to functions as follows:<ul>
<li><b>Separator:</b> Evaluates to the identity function.</li>
<li><b>Operand:</b> Evaluates to a constant function that pushes the operand, followed by all input terms, onto the output program.</li>
<li><b>Operator:</b> Evaluates to the operation defined for the operator in the environment. If none, evaluates to a constant function that pushes the operator, followed by all input terms, onto the output program.</li>
</ul>
</li>
<li>Programs that contain <b>multiple elements</b> can be considered a concatenation of sub-programs that each contain one of the elements. The concatenated program evaluates to the composition of the functions that each sub-program evaluates to.</li>
</ul>
<p>For example, program "A B" is the concatenation of programs "A", " ", and "B". The separator evaluates to the identity operation and can be disregarded. The programs "A" and "B" evaluate to functions which will be denoted as <code>A</code> and <code>B</code>, respectively. The input and output are handled by the composed function as follows:</p>
<ul>
<li>Function <code>B</code> receives the input, and its output becomes the input for function <code>A</code>.</li>
<li>Function <code>A</code> receives the input, and its output becomes that of the composed function.</li>
</ul>
<p>Any programs may be concatenated together; however, note that concatenating programs "A" and "B" without an intervening separator would result in a program containing a single operator "AB", which is unrelated to operators "A" or "B".</p>
<h2><a class="anchor" id="language__functions__operations__"></a>
Operations</h2>
<p>All operation implementations provided are documented in the <a class="el" href="group__om____operation____.html">Operation</a> module.</p>
<h1><a class="anchor" id="language__data__"></a>
Data</h1>
<p>There are no traditional data types in Om: every data value is represented by an operand.</p>
<h2><a class="anchor" id="language__data__panmorphism__"></a>
Panmorphism</h2>
<p>Om uses a unique <em>panmorphic</em> type system, from Ancient Greek πᾶν (pan, "all") and μορφή (morphē, “form”), in which all data values are exposed exclusively through a common immutable interface.</p>
<p>In the case of Om, every data value is entirely represented in the language as an operand. Any operation will accept any operand as a valid input and interrogate its data solely through its contained program (a sequence of operator, separator, and/or operand). The operation is then free to process the data however is appropriate, and any operand that it produces as output can then be interrogated and processed by the next operation in the same way.</p>
<h2><a class="anchor" id="language__data__implementation__"></a>
Implementation</h2>
<p>Although any operand can be treated as containing a literal array of operand, operator and/or separator elements, the implementation of operands takes advantage of some optimizations:</p>
<ul>
<li>Each operand in memory actually contains one of several possible program implementations, each optimized for a specific set of operations. For example, some operations treat separators as insignificant; operands produced by these operations could contain a program implementation that stores only terms (operators and/or operands) and presents a "normalized" separator (such as a line separator) between each term.</li>
<li>Operations can interrogate an input operand for its program implementation type; if it is the optimal implementation type for the operation, the operation can manipulate the operand directly to produce the same result more efficiently.</li>
</ul>
<p>Operations in a program can be ordered by the programmer to increase performance by minimizing conversions between program implementations, but it is not necessary for obtaining a correct computation. Where relevant, an operation will document the program implementation types of its inputs and outputs to allow for this optional level of optimization.</p>
<h2><a class="anchor" id="language__data__programs__"></a>
Programs</h2>
<p>All program implementations provided are documented in the <a class="el" href="group__om____program____.html">Program</a> module.</p>
<h1><a class="anchor" id="language__examples__"></a>
Examples</h1>
<p>The following program contains a single operand containing an operator "<code>Hello,</code>", a separator "<code> </code>", and another operator "<code>world!</code>":</p>
<ul>
<li><code>{Hello, world!}</code> <blockquote class="doxtable">
<p><code>{Hello, world!}</code></p>
</blockquote>
</li>
</ul>
<p>The following program contains a single operand containing an operator "<code>Hello,</code>", a separator "<code> </code>", and an operand "<code>{universe!}</code>" which in turn contains a single operator "<code>universe!</code>":</p>
<ul>
<li><code>{Hello, {universe!}}</code> <blockquote class="doxtable">
<p><code>{Hello, {universe!}}</code></p>
</blockquote>
</li>
</ul>
<p>Note that separators are significant inside operands:</p>
<ul>
<li><code>{Hello, &#160;&#160;world!}</code> <blockquote class="doxtable">
<p><code>{Hello, &#160;&#160;world!}</code></p>
</blockquote>
</li>
</ul>
<p>Operands can be dropped and copied via the <a class="el" href="group__om____operation____drop__operation____.html">drop</a> and <a class="el" href="group__om____operation____copy__operation____.html">copy</a> operations:</p>
<ul>
<li><code>drop {A}{B}{C}</code> <blockquote class="doxtable">
<p><code>{B}{C}</code></p>
</blockquote>
</li>
<li><code>copy {A}{B}{C}</code> <blockquote class="doxtable">
<p><code>{A}{A}{B}{C}</code></p>
</blockquote>
</li>
<li><code>drop copy {A}</code> <blockquote class="doxtable">
<p><code>{A}</code></p>
</blockquote>
</li>
<li><code>copy copy {A}</code> <blockquote class="doxtable">
<p><code>{A}{A}{A}</code></p>
</blockquote>
</li>
</ul>
<p>The <a class="el" href="group__om____operation____drop__operation____.html">drop</a> operation can therefore be used for comments:</p>
<ul>
<li><code>drop {This is a comment.} {This is not a comment.}</code> <blockquote class="doxtable">
<p><code>{This is not a comment.}</code></p>
</blockquote>
</li>
</ul>
<p>The <a class="el" href="group__om____operation____choose__operation____.html">choose</a> operation selects one of two operands, depending on whether a third is empty:</p>
<ul>
<li><code>choose {It was empty.}{It was non-empty.}{I am not empty.}</code> <blockquote class="doxtable">
<p><code>{It was non-empty.}</code></p>
</blockquote>
</li>
<li><code>choose {It was empty.}{It was non-empty.}{}</code> <blockquote class="doxtable">
<p><code>{It was empty.}</code></p>
</blockquote>
</li>
</ul>
<p>An operation without sufficient operands evaluates to itself and whatever operands are provided:</p>
<ul>
<li><code>drop</code> <blockquote class="doxtable">
<p><code>drop</code></p>
</blockquote>
</li>
<li><code>choose {It was empty.}{It was non-empty.}</code> <blockquote class="doxtable">
<p><code>choose{It was empty.}{It was non-empty.}</code></p>
</blockquote>
</li>
</ul>
<p>The <a class="el" href="group__om____operation____quote__operation____.html">quote</a> and <a class="el" href="group__om____operation____dequote__operation____.html">dequote</a> operations add and remove a layer of operand braces, respectively:</p>
<ul>
<li><code>quote {B}</code> <blockquote class="doxtable">
<p><code>{{B}}</code></p>
</blockquote>
</li>
<li><code>dequote {{B}}</code> <blockquote class="doxtable">
<p><code>{B}</code></p>
</blockquote>
</li>
<li><code>dequote {copy}</code> <blockquote class="doxtable">
<p><code>copy</code></p>
</blockquote>
</li>
<li><code>dequote {copy} {A}</code> <blockquote class="doxtable">
<p><code>{A}{A}</code></p>
</blockquote>
</li>
</ul>
<p>Operands can be popped from and pushed into:</p>
<ul>
<li><code>&lt;-[characters] {ABC}</code> <blockquote class="doxtable">
<p><code>{A}{BC}</code></p>
</blockquote>
</li>
<li><code>-&gt;[literal] {A}{BC}</code> <blockquote class="doxtable">
<p><code>{ABC}</code></p>
</blockquote>
</li>
<li><code>&lt;-[terms] {some terms}</code> <blockquote class="doxtable">
<p><code>{some}{terms}</code></p>
</blockquote>
</li>
</ul>
<p>A new operator definition can be provided with the <a class="el" href="group__om____operation____define__operation____.html">define</a> operation, where the first operand is treated as containing a <a class="el" href="group__om____lexicon____.html">Lexicon</a> with operator-to-operand mappings, and the second operand contains the program to evaluate using the defined operator:</p>
<ul>
<li><code>define { double-quote {quote quote} } { double-quote {A} }</code> <blockquote class="doxtable">
<p><code>{{{A}}}</code></p>
</blockquote>
</li>
</ul>
<p>Any string can be used as an operator, with separators and operand braces escaped with a backquote:</p>
<ul>
<li><code>define { double` quote {quote quote} } { double` quote {A} }</code> <blockquote class="doxtable">
<p><code>{{{A}}}</code></p>
</blockquote>
</li>
<li><code>&lt;-[terms] { double` quote operator }</code> <blockquote class="doxtable">
<p><code>{double` quote}{operator}</code></p>
</blockquote>
</li>
</ul>
<p>Unicode is fully supported:</p>
<ul>
<li><code>&lt;-[characters] {한글}</code> <blockquote class="doxtable">
<p><code>{한}{글}</code></p>
</blockquote>
</li>
<li><code>&lt;-[code` points] {한글}</code> <blockquote class="doxtable">
<p><code>{ᄒ}{ᅡᆫ글}</code></p>
</blockquote>
</li>
<li><code>&lt;-[terms] {한글 韓}</code> <blockquote class="doxtable">
<p><code>{한글}{韓}</code></p>
</blockquote>
</li>
</ul>
<p>Strings are automatically <a href="http://unicode.org/reports/tr15">normalized</a> to <a href="http://unicode.org/reports/tr15/#Norm_Forms">NFD</a>, but can be explicitly normalized to <a href="http://unicode.org/reports/tr15/#Norm_Forms">NFKD</a> using the <a class="el" href="group__om____operation____normalize__operation____.html">normalize</a> operation:</p>
<ul>
<li><code>normalize {2⁵}</code> <blockquote class="doxtable">
<p><code>{25}</code></p>
</blockquote>
</li>
</ul>
<p>Recursion is very efficient in Om, due to (a) the "eager" evaluation model enabled by prefix concatenative syntax (i.e. data is consumed immediately rather than being left on a stack), and (b) the non-recursive evaluation implementation in the evaluator that minimizes memory overhead of recursive calls and prevents stack overflow. The following example uses recursion to give the minutes in a colon-delimited 24-hour time string:</p>
<ul>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { minutes {1:23} }<br/>
 </code> <blockquote class="doxtable">
<p><code>{23}</code></p>
</blockquote>
</li>
</ul>
<p>Each step of an evaluation can be represented as a program. The following is the above program broken down into evaluation steps, where the code that is about to be replaced is <b>bold</b>, and the latest replacement is <em>italicized</em>:</p>
<ul>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { <b>minutes</b> {1:23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { <em>dequote choose {minutes} {} = {:} &lt;-[characters]</em> {1:23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { dequote choose {minutes} {} = {:} <b>&lt;-[characters] {1:23}</b> }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { dequote choose {minutes} {} = {:} <em>{1} {:23}</em> }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { dequote choose {minutes} {} <b>= {:} {1}</b> {:23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { dequote choose {minutes} {} <em>{}</em> {:23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { dequote <b>choose {minutes} {} {}</b> {:23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { dequote <em>{minutes}</em> {:23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { <b>dequote {minutes}</b> {:23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { <em>minutes</em> {:23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { <b>minutes</b> {:23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { <em>dequote choose {minutes} {} = {:} &lt;-[characters]</em> {:23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { dequote choose {minutes} {} = {:} <b>&lt;-[characters] {:23}</b> }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { dequote choose {minutes} {} = {:} <em>{:} {23}</em> }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { dequote choose {minutes} {} <b>= {:} {:}</b> {23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { dequote choose {minutes} {} <em>{{:}}</em> {23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { dequote <b>choose {minutes} {} {{:}}</b> {23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { dequote <em>{}</em> {23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { <b>dequote {}</b> {23} }<br/>
 </code></li>
<li><code>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { {23} }<br/>
 </code></li>
<li><code><b>define<br/>
 { minutes { dequote choose {minutes} {} = {:} &lt;-[characters] } }<br/>
 { {23} }</b><br/>
 </code></li>
<li><code><em>{23}</em></code></li>
</ul>
<p>The <a class="el" href="group__om____operation____rearrange__operation____.html">rearrange</a> operation provides operand name binding, allowing for a more applicative style. The following example is a simplistic implementation of a left <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">fold</a>, along with an example call: </p>
<pre class="fragment">define
{
	[Fold]&lt;- {
		rearrange
		{
			rearrange
			{
				dequote
				choose
				quote Result
				pair pair pair {[Fold]&lt;-} Function Result Remainder
				Remainder
			}
			{Result Remainder}
			dequote Function Base &lt;-[terms] Source
		}
		{Function Base Source}
	}
}
{
	[Fold]&lt;- {[literal]&lt;-} {} {1 2 3}
}</pre><p>The result is <code>{321}</code>.</p>
<p>The example works as follows:</p>
<ul>
<li><code>[Fold]&lt;-</code> takes three operands:<ul>
<li><code>Function</code></li>
<li><code>Base</code></li>
<li><code>Source</code></li>
</ul>
</li>
<li>The first term is popped from the <code>Source</code>.</li>
<li>The <code>Function</code> is applied to:<ul>
<li>the <code>Base</code></li>
<li>the popped first term of the <code>Source</code></li>
<li>the remainder of the <code>Source</code></li>
<li>the remainder of the input program</li>
</ul>
</li>
<li>The first two operands output by the <code>Function</code> are:<ul>
<li><code>Result</code></li>
<li><code>Remainder</code></li>
</ul>
</li>
<li>If the <code>Remainder</code> is empty, the <code>Result</code> is output. Otherwise, <code>Function</code>, <code>Result</code>, and <code>Remainder</code> are passed to a recursive <code>[Fold]&lt;-</code> call.</li>
</ul>
<p>A few things should be noted about the above example:</p>
<ul>
<li>The <a class="el" href="group__om____operation____.html">Operation</a> list is very short at the moment; as it expands, higher-level constructs should allow for simplification of algorithms such as this one.</li>
<li>When reading Om code, it can be difficult to mentally group operations with the operands they consume (contrasted with Scheme, in which they are grouped at design time with parentheses). However, it should be possible for an Om integrated development environment to generate a graphical indication of these groupings dynamically.</li>
</ul>
<h1><a class="anchor" id="language__references__"></a>
References</h1>
<p>The following additional reading may help explain some of the concepts that contributed to Om:</p>
<ul>
<li><a href="http://evincarofautumn.blogspot.ca/2012/02/why-concatenative-programming-matters.html">Why Concatenative Programming Matters</a></li>
<li>The Concatenative <a href="http://concatenative.org">wiki</a>, <a href="http://tech.groups.yahoo.com/group/concatenative">mailing list</a>, and <a href="http://en.wikipedia.org/wiki/Concatenative_programming_language">Wikipedia entry</a></li>
<li>A <a href="http://www.kevinalbrecht.com/code/joy-mirror">mirror</a> of Manfred von Thun's original pages on the groundbreaking Joy Programming Language (<a href="http://en.wikipedia.org/wiki/Joy_(programming_language)">Wikipedia entry</a>), the father of all concatenative languages </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
		<!-- start footer part -->
	</body>
</html>
