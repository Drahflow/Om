/*!
\file
	\brief
		Om hpp file.
	\version
		0.1.2
	\date
		2012-2013
	\copyright
		Copyright (c) Jason Erb.
		All rights reserved.  This program and the accompanying materials are
		made available under the terms of the
		<a href="http://www.eclipse.org/legal/epl-v10.html">Eclipse
		Public License, Version 1.0</a>, which accompanies this distribution.
	\authors
		Jason Erb - Initial API, implementation, and documentation.

\mainpage Main Page

\tableofcontents

\section introduction Introduction

The development of the <a href="http://om-language.org">Om language</a> was
guided by a single question:

<em>What is the simplest possible abstract syntax that can articulate any
algorithm for precise, efficient evaluation?</em>

The result is a fundamentally simple and unique programming language.

%Om is:
-	A <b>concatenative, homoiconic programming language</b> with:
	-	An extremely minimal syntax, comprised of only three elements.
	-	Prefix, rather than postfix, notation.  Instead of a data stack,
		functions manipulate the remainder of the program itself.
	-	A unique <em>panmorphic</em> type system in which there is only one data
		type&mdash;the program&mdash;exposed in the language, even though the
		implementation can optimize data representations for operations.
-	An <b>abstract algorithmic notation</b> that does not rely on any computer
	implementation details (such as byte or machine word length).
-	A <b>data transfer format</b> that is trivial to parse.
-	<b>Embeddable</b>: implemented as a header-only C++ library (with only
	<a href="http://boost.org">Boost</a> and
	<a href="http://icu-project.org">ICU</a> dependencies) that can be
	incorporated into any C++ or Objective-C++ program.
-	<b>Extensible</b>: new native operations can be implemented as C++ classes.
-	<b>Unicode-correct</b>: any
	<a href="http://www.utf8everywhere.org">UTF-8</a> text (without byte-order
	marker) defines a valid %Om program.

%Om is <b>not</b>:
-	<b>Complete</b>.  Although the intent is to develop %Om into a full-featured
	language, the software is currently at a very early "proof of concept"
	stage, requiring the addition of many operations (such as basic number and
	file operations) and optimizations before it can be considered useful for
	any real-world purpose.  It has been made available in order to demonstrate
	the underlying concepts and welcome others to get involved in early
	development.
-	<b>Stationary</b>.  %Om will likely undergo significant changes on its way
	to version 1.0.

\section background Background

The following reading may help explain some of the concepts that contributed to
%Om:
-	<a href="http://evincarofautumn.blogspot.ca/2012/02/why-concatenative-programming-matters.html">Why
	Concatenative Programming Matters</a>
-	The Concatenative <a href="http://concatenative.org">wiki</a>,
	<a href="http://tech.groups.yahoo.com/group/concatenative">mailing list</a>,
	and
	<a href="http://en.wikipedia.org/wiki/Concatenative_programming_language">Wikipedia
	entry</a>
-	A <a href="http://www.kevinalbrecht.com/code/joy-mirror">mirror</a> of
	Manfred von Thun's original pages on the groundbreaking
	Joy Programming Language
	(<a href="http://en.wikipedia.org/wiki/Joy_(programming_language)">Wikipedia
	entry</a>), the father of all concatenative languages

\section syntax Syntax

An %Om <b>program</b> is a combination of three elements&mdash;operator,
separator, and operand&mdash;as follows:

\image html "program.png"

\subsection syntax__operator Operator

An <b>operator</b> has the following syntax:

\image html "operator.png"

Backquotes (<tt>`</tt>) in operators are disregarded if the code point following
is not a backquote, operand brace, or separator code point.

\subsection syntax__separator Separator

A <b>separator</b> has the following syntax:

\image html "separator.png"

\subsection syntax__operand Operand

An <b>operand</b> has the following syntax:

\image html "operand.png"

\section evaluation Evaluation

Each program evaluates to a function.

\subsection evaluation__functions Functions

A function takes a program as input and returns a program as output.

A function pulls elements from the front of the input program and pushes
elements to the back of the output program.  Only <em>terms</em> (operators and
operands) are significant to functions; separators are discarded from input, and
are inserted between output terms in a "normalized" form (for consistent
formatting and proper operator separation).  Therefore, only input and output
terms are relevant in describing a function.

There are three fundamental types of functions:
-	<b>Identity</b>: Pushes all input terms onto the output program.
-	<b>Constant</b>: Pushes a term defined by the function, followed by all
	input terms, onto the output program.
-	<b>Operation</b>: Processes the input terms as follows:
	-	<b>Operand</b>: Processes the operand as data for a computation, defined
		by the operation, and pushes any terms generated by the computation onto
		the output program.  When the computation is "complete", any additional
		operands are pushed onto the output program, unchanged.
	-	<b>Operator</b>: Pushes the operator, followed by all remaining input
		terms, onto the output program.

\subsection evaluation__program_types Programs

This section describes how each program is evaluated into a function.

\subsubsection evaluation__program_types__empty Empty Program

The empty program evaluates to the identity function.

\subsubsection evaluation__program_types__single Single-Element Programs

Programs that contain only a single element evaluate to functions as follows:
-	<b>Separator</b>: Evaluates to the identity function.
-	<b>Operand</b>: Evaluates to a constant function that pushes the
	operand, followed by all input terms, onto the output program.
-	<b>Operator</b>: Evaluates to the operation defined for the operator
	in the environment; if none, evaluates to a constant function that
	pushes the operator, followed by all input terms, onto the output
	program.

\subsubsection evaluation__program_types__multiple Multiple-Element Programs

Programs that contain multiple elements can be considered a concatenation of
sub-programs that each contain one of the elements.  The concatenated program
thus evaluates to the composition of the functions that each sub-program
evaluates to.

For example, program "A B" is the concatenation of programs "A", " ", and "B".
The separator evaluates to the identity operation and can be disregarded.  The
programs "A" and "B" evaluate to functions which will be denoted as <tt>A</tt>
and <tt>B</tt>, respectively.  The input and output is handled by the composed
function is as follows:
-	Function <tt>B</tt> receives the input, and sends its output to function
	<tt>A</tt>.
-	Function <tt>A</tt> receives the input, and its output becomes that of the
	composed function.

Any programs may be concatenated together; however, note that concatenating
programs "A" and "B" without an intervening separator would result in a program
containing a single operator "AB", which is unrelated to operators "A" or "B".

\subsection evaluation__operations Operations

All operation implementations provided are documented in the \ref operations
module.

\subsection evaluation__data_types Data Types

%Om uses a novel <em>panmorphic</em> type system in which all data values are
represented within the language solely through a common program interface
(comprised of only separators, operators, and/or operands).  Any operation will
accept any operand as a valid input and interpret it however the operation deems
appropriate.

There are no traditional data types in the language; data types are relegated to
an implementation layer and represent optimizations for a set of operations.
Each operand in memory contains a single program implementation; by default,
this is the \ref literal program, which preserves all data in the operand,
verbatim (including separators).  However, an operation may prefer an operand to
have a different program implementation that is optimized for specific
functionality used by the operation.  The \ref find_operation operation, for
example, prefers one of its operands to have a \ref lexicon program type for
fast mapping from operator to operand.  In such cases, an operation can simply
convert an undesired program implementation to the desired type through the
common program interface without impacting the semantics of the program.

Operations in a program can be ordered by the programmer to increase performance
by minimizing conversions between program implementations, but it is not
necessary for obtaining a correct computation.  Data types in %Om therefore
become an optimization-phase implementation detail.

All program implementations provided are documented in the \ref programs module.

\subsection evaluation__evaluator Evaluator

The evaluator reads, parses and evaluates the input stream in a single pass,
sending results to the output stream as soon as they can be evaluated.  This is
possible because %Om uses prefix notation rather than the postfix notation
typical of concatenative languages.  Prefix notation has the following
advantages over postfix notation:

-	Stack underflows are impossible.
-	Operations can be optimized to only read into memory the data that is
	required; stack-based postfix languages have no knowledge of the operation
	to apply until the data is already in memory, on the stack.
-	An IDE can provide hints to the user about the data that is expected by an
	operation.

\section examples Examples

The following program contains a single operand:
-	<tt>{Hello, world!}</tt>
	<blockquote><tt>{Hello, world!}</tt></blockquote>

Operands can be dropped and copied via the \ref drop_operation and
\ref copy_operation operations:
-	<tt>drop {A}{B}{C}</tt>
	<blockquote><tt>{B}{C}</tt></blockquote>
-	<tt>copy {A}{B}{C}</tt>
	<blockquote><tt>{A}{A}{B}{C}</tt></blockquote>
-	<tt>drop copy {A}</tt>
	<blockquote><tt>{A}</tt></blockquote>
-	<tt>copy copy {A}</tt>
	<blockquote><tt>{A}{A}{A}</tt></blockquote>

The \ref drop_operation operation can therefore be used for comments:
-	<tt>drop {This is a comment.} {This is not a comment.}</tt>
	<blockquote><tt>{This is not a comment.}</tt></blockquote>

The \ref choose_operation operation selects one of two operands, depending on
whether a third is empty:
-	<tt>choose {It was empty.}{It was non-empty.}{I am not empty.}</tt>
	<blockquote><tt>{It was non-empty.}</tt></blockquote>
-	<tt>choose {It was empty.}{It was non-empty.}{}</tt>
	<blockquote><tt>{It was empty.}</tt></blockquote>

An operation without sufficient operands evaluates to itself and whatever
operands are provided:
-	<tt>drop</tt>
	<blockquote><tt>drop</tt></blockquote>
-	<tt>choose {It was empty.}{It was non-empty.}</tt>
	<blockquote><tt>choose{It was empty.}{It was non-empty.}</tt></blockquote>

The \ref quote_operation and \ref dequote_operation operations add and remove a
layer of operand braces, respectively:
-	<tt>quote {B}</tt>
	<blockquote><tt>{{B}}</tt></blockquote>
-	<tt>dequote {{B}}</tt>
	<blockquote><tt>{B}</tt></blockquote>
-	<tt>dequote {copy}</tt>
	<blockquote><tt>copy</tt></blockquote>
-	<tt>dequote {copy} {A}</tt>
	<blockquote><tt>{A}{A}</tt></blockquote>

Operands can be popped from and pushed into:
-	<tt>&lt;-characters {ABC}</tt>
	<blockquote><tt>{A}{BC}</tt></blockquote>
-	<tt>-&gt;literal {A}{BC}</tt>
	<blockquote><tt>{ABC}</tt></blockquote>
-	<tt>&lt;-terms {some terms}</tt>
	<blockquote><tt>{some}{terms}</tt></blockquote>

A new operator definition can be provided with the \ref define_operation
operation, where the first operand is treated as containing a \ref lexicon with
operator-to-operand mappings, and the second operand contains the program to
evaluate using the defined operator:
-	<tt>define { double-quote {quote quote} } { double-quote {A} }</tt>
	<blockquote><tt>{{{A}}}</tt></blockquote>

Any string can be used as an operator, with separators and operand braces
escaped with a backquote:
-	<tt>define { double` quote {quote quote} } { double` quote {A} }</tt>
	<blockquote><tt>{{{A}}}</tt></blockquote>
-	<tt>&lt;-terms { double` quote operator }</tt>
	<blockquote><tt>{double` quote}{operator}</tt></blockquote>

Unicode is fully supported:
-	<tt>&lt;-characters {한글}</tt>
	<blockquote><tt>{한}{글}</tt></blockquote>
-	<tt>&lt;-code` points {한글}</tt>
	<blockquote><tt>{ᄒ}{ᅡᆫ글}</tt></blockquote>
-	<tt>&lt;-terms {한글 韓}</tt>
	<blockquote><tt>{한글}{韓}</tt></blockquote>

Strings are automatically
<a href="http://unicode.org/reports/tr15">normalized</a> to
<a href="http://unicode.org/reports/tr15/#Norm_Forms">NFD</a>, but can be
explicitly normalized to
<a href="http://unicode.org/reports/tr15/#Norm_Forms">NFKD</a> using the
\ref normalize_operation operation:
-	<tt>normalize {2⁵}</tt>
	<blockquote><tt>{25}</tt></blockquote>

Recursion is very efficient in %Om, due to (a) the "eager" evaluation model
enabled by prefix concatenative syntax (i.e. data is consumed immediately rather
than being left on a stack), and (b) the non-recursive evaluation implementation
in the evaluator that minimizes memory overhead of recursive calls and prevents
stack overflow.  The following example uses recursion to give the minutes in a
colon-delimited 24-hour time string:
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ minutes {1:23} }<br/>
	</tt>
	<blockquote><tt>{23}</tt></blockquote>

Each step of an evaluation can be represented as a program.  The following is
the above program broken down into evaluation steps, where the code that is
about to be replaced is <b>bold</b>, and the latest replacement is
<em>italicized</em>:
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <b>minutes</b> {1:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <em>dequote choose {minutes} {} = {:} &lt;-characters</em> {1:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} = {:} <b>&lt;-characters {1:23}</b> }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} = {:} <em>{1} {:23}</em> }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} <b>= {:} {1}</b> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} <em>{}</em> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote <b>choose {minutes} {} {}</b> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote <em>{minutes}</em> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <b>dequote {minutes}</b> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <em>minutes</em> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <b>minutes</b> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <em>dequote choose {minutes} {} = {:} &lt;-characters</em> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} = {:} <b>&lt;-characters {:23}</b> }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} = {:} <em>{:} {23}</em> }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} <b>= {:} {:}</b> {23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} <em>{{:}}</em> {23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote <b>choose {minutes} {} {{:}}</b> {23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote <em>{}</em> {23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <b>dequote {}</b> {23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ {23} }<br/>
	</tt>
-	<tt><b>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ {23} }</b><br/>
	</tt>
-	<tt><em>{23}</em></tt>

\section downloading Downloading

Code can be downloaded from the <a href="https://github.com/sparist/Om">Om
GitHub repository</a>.

-	<b>Current version</b>:
	<a href="https://github.com/sparist/Om">main page</a>
-	<b>Released versions</b>:
	<a href="https://github.com/sparist/Om/tags">Tags page</a>

\section building Building

Although it should be possible to build the code on any mainstream platform, it
has only been built and tested on:
-	Xcode 4.5.2 on Mac OS X 10.8.2 (Mountain Lion)
-	Visual Studio 2010 Express on Windows Vista

The project is generated by CMake, and contains the following targets:
-	<b>%Om</b>: builds the interpreter project into
	<tt>products/</tt><em>platform</em>.
-	<b>%Om Documentation</b>: builds the documentation into
	<tt>products/doxygen</tt>.
	Open <tt>html/index.html</tt> to view the HTML documentation in a browser.

\subsection building__xcode Xcode

Building in Xcode requires:
-	<a href="http://itunes.apple.com/us/app/xcode/id497799835?ls=1&mt=12">Xcode</a>
-	<a href="http://doxygen.org">Doxygen</a> and
	<a href="http://www.macports.org/ports.php?by=name&substr=graphviz">Graphviz
	(via MacPorts)</a>

To generate the <tt>Om.xcodeproj</tt> file (in <tt>products/xcode</tt>):
-	Ensure that Doxygen and Graphviz are installed, and in the path variable
	visible to applications.
	<a href="http://overwatering.org/blog/2012-2013/08/setting-path-osx-mountain-lion">This
	article</a> explains how to do so.
-	Clone the Git repository.
-	Run <tt>make.sh</tt> and pass it the following arguments (in order):
	- 	The ICU root directory path.  To create this directory, download and
		unpack the
		<a href="http://download.icu-project.org/files/icu4c/50.1.2/icu4c-50_1_1-src.tgz">ICU4C
		50.1.2 code archive</a> from the
		<a href="http://site.icu-project.org/download">ICU download page</a>.
	-	The Boost root directory path.  To create this directory, download and
		unpack the
		<a href="http://sourceforge.net/projects/boost/files/boost/1.52.0/boost_1_52_0.tar.gz/download">Boost
		1.52.0 code archive</a> from the
		<a href="http://www.boost.org/users/download">Boost download page</a>.
	-	<b>Optional:</b> The UnitTest++ root directory path.  If omitted, unit
		tests will be excluded from the build.  To create this directory,
		download and unpack the
		<a href="http://sourceforge.net/projects/unittest-cpp/files/latest/download?source=files">UnitTest++
		1.4 code archive</a> from the
		<a href="http://sourceforge.net/projects/unittest-cpp/files">UnitTest++
		download page</a>.

To update the Xcode project to reflect changes to the code directory tree:
-	Run <tt>remake.sh</tt>.

To remove the directory generated by <tt>make.sh</tt>:
-	Run <tt>unmake.sh</tt>.

\subsection building__visual_studio Visual Studio

Building in Visual Studio requires:
-	<a href="http://www.microsoft.com/visualstudio/eng/downloads">Visual Studio
	2010</a>
-	<a href="http://msysgit.github.com">Git</a>
-	<a href="http://www.cmake.org">CMake</a>
-	<a href="http://doxygen.org">Doxygen</a> and
	<a href="http://graphviz.org">Graphviz</a>
-	<a href="http://subversion.tigris.org">Subversion</a> (if unit tests are to
	be included)

To generate the <tt>Om.sln</tt> file (in <tt>products/vs</tt>):
-	Ensure that Doxygen and Graphviz are installed, and in the path variable.
-	Clone the Git repository.
-	Run <tt>make.bat</tt> and pass it the following arguments (in order):
	- 	The ICU root directory path.  To create this directory, download and
		unpack the
		<a href="http://download.icu-project.org/files/icu4c/49.1.2/icu4c-49_1_2-src.zip">ICU4C
		49.1.2 code archive</a> from the
		<a href="http://site.icu-project.org/download">ICU download page</a>.
		(Note that there is presently a
		<a href="https://svn.boost.org/trac/boost/ticket/7839">Boost bug</a>
		that prevents building against ICU4C 50.1.2 on Windows.)
	-	The Boost root directory path.  To create this directory, download and
		unpack the
		<a href="http://sourceforge.net/projects/boost/files/boost/1.52.0/boost_1_52_0.zip/download">Boost
		1.52.0 code archive</a> from the
		<a href="http://www.boost.org/users/download">Boost download page</a>.
	-	<b>Optional:</b> The UnitTest++ root directory path.  If omitted, unit
		tests will be excluded from the build.  To create this directory, get
		the UnitTest++ 1.4 code via Subversion checkout (described on the
		<a href="https://sourceforge.net/projects/unittest-cpp/develop">UnitTest++
		developer page</a>) and apply the patch attached to the
		<a href="https://sourceforge.net/tracker/?func=detail&aid=3583690&group_id=158151&atid=806686">Visual
		Studio 2010 support ticket</a>.  The UnitTest++ root directory is the
		<tt>UnitTest++</tt> subdirectory of the Subversion checkout directory.

To update the Visual Studio solution to reflect changes to the code directory
tree:
-	Run <tt>remake.bat</tt>.

To remove the directory generated by <tt>make.bat</tt>:
-	Run <tt>unmake.bat</tt>.

\section using Using

The %Om interpreter takes input from the standard input stream, ending at the
first unbalanced end brace, and sends output to the standard output stream.

%Om can be incorporated into any C++ or Objective-C++ project as follows:
-	Add the %Om <tt>code</tt> directory to the include path and include the
	desired files.  Inclusion of any operation files will automatically add the
	corresponding operation to the global system.
-	Link to the required <a href="http://icu-project.org">ICU (ICU4C 49.1.2)</a>
	and/or <a href="http://boost.org">Boost (1.51.0)</a> library dependencies.
-	Call the <tt>Om::System::Initialize</tt> function prior to use (eg. in the
	<tt>main</tt> function), passing in the desired UTF-8 locale (eg.
	"en_US.UTF-8").
-	Construct an <tt>Om::Environment</tt>, populate with any additional
	operator-program mappings, and call one of its <tt>Evaluate</tt> functions
	to evaluate a program.

\section developing Developing

%Om is written in modern, portable C++ and can be forked from the
<a href="http://github.com/sparist/Om">%Om GitHub repository</a>.

<b>Note</b>: Because this is an early-stage project, there are not yet any
compatibility guarantees between versions.

\subsection developing__coding_standard Coding Standard

All %Om development must adhere to the
<a href="http://sparist.github.com/cpp_coding_standard.html">Sparist C++ Coding
Standard</a>.

\subsection developing__adding_operations Adding Operations

Additional native functionality can be added to %Om by implementing new
operations in C++.

There are two ways to implement an operation: as a composite operation, or an
atomic operation.

To implement a composite operation, or an atomic operation that consumes no
operands:
-	Define the operation <tt>struct</tt> in the <tt>Om::Operations</tt>
	namespace.
-	Define the static <tt>GetName()</tt> method, which returns a <tt>static char
	const *</tt> containing the name.
-	Define the static <tt>Give( Evaluation &amp; )</tt> method, with no return
	value, to give existing operations and/or elements to the evaluation.

To define an atomic operation that consumes one or more operands:
-	Define the operation <tt>struct</tt>, derived from
	<tt>Om::DefaultOperation&lt;</tt> <em>operation</em> <tt>&gt;</tt> (where
	<em>operation</em> is the name of the operation <tt>struct</tt>), in the
	<tt>Om::Operations</tt> namespace.
-	Define the static <tt>GetName()</tt> method, which returns a <tt>static char
	const *</tt> containing the name.
-	Add the implementation, using existing operations as a guide:
	-	Implement the functions necessary to compile.
	-	Optionally override virtual function implementations in
		<tt>DefaultOperation</tt>, such as <tt>ReadQuotedElements</tt>, that may
		be more optimally implemented in the operation.

For any operation implementation, code must be added to the operation header
that inserts the operation into the system when the header is included, as
follows (where <tt>WhateverOperation</tt> is a stand-in for the name of the
operation <tt>struct</tt>):

<code>
	namespace<br/>
	{<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;static Definition< WhateverOperation > const
	theWhateverDefinition;<br/>
	}
</code>

\subsection developing__adding_programs Adding Programs

New data types can be added to %Om by extending <tt>Om::Program</tt> and
defining the functions necessary to instantiate the class.  Use existing
programs as a guide.

Program types should be defined in the <tt>Om</tt> namespace.

\subsection developing__analyzing_code Analyzing Code

Some basic free static analysis tools can be applied to the %Om code.

-	<a href="https://github.com/terryyin/hfcca"><b>HFCCA</b></a> is a Python
	script that measures cyclomatic complexity and counts the number of lines of
	code in C++ source files, not including comments or tests.  If Python is
	installed and in the path, HFCCA can be applied to %Om by entering the
	following at the terminal from inside the %Om directory:
	<blockquote><tt>python hfcca.py -p -v code</tt></blockquote>
-	<a href="http://cloc.sourceforge.net"><b>CLOC</b></a> is a stand-alone Perl
	script that determines total line counts.  If Perl is installed, CLOC can be
	applied to %Om by entering the following at the terminal from inside the
	%Om directory:
	<blockquote><tt>cloc.pl code</tt></blockquote>

\section issue_tracking Issue Tracking

Issues are reported and tracked with the
<a href="https://github.com/sparist/Om/issues">Om GitHub issue tracker</a>.

Before reporting an issue, please search existing issues first to ensure that it
is not a duplicate.

\section license License

This program and the accompanying materials are made available under the terms
of the <a href="http://www.eclipse.org/legal/epl-v10.html">Eclipse Public
License, Version 1.0</a>, which accompanies this distribution.

For more information about this license, please see the
<a href="http://www.eclipse.org/legal/eplfaq.php">Eclipse Public License
FAQ</a>.

\section contributing Contributing

There are several ways to contribute to the %Om project:

-	By funding development of the %Om language, either for general or
	domain-specific functionality.  If interested, please contact me at <a
		href="mailto:information@sparist.com?subject=Om%20Funding"
	>information@sparist.com</a>.
-	By developing new \ref operations and \ref programs.  See \ref developing
	for details.
-	By reporting bugs, patches, or enhancement requests.  See
	\ref issue_tracking for details.

*/
#if !defined( Om_ )
	#define Om_ Om

//! The Om language implementation.
namespace Om
{
}

#endif
