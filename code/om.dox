/*!
\mainpage Introduction

The development of the <a href="http://om-language.org">Om language</a> was guided by a single question:

<em>What is the simplest high-level programming language possible?</em>

%Om is:
-	A <b>concatenative, homoiconic programming language</b> with:
	-	A <b>minimal syntax</b> comprised of only three elements.
	-	<b>Prefix notation</b> rather than postfix.  Instead of a data stack, functions manipulate the remainder of the program itself.
	-	A unique <em>panmorphic</em> type system in which there is only <b>one data type</b>&mdash;the program&mdash;exposed in the language, even though the implementation can optimize data representations for operations.
-	An <b>algorithm notation language</b> that is completely abstracted from any concept of a computer.
-	A <b>data transfer format</b> that is trivial to parse.
-	A <b>C++ scripting library</b> that can be:
	-	<b>Embedded</b> into any C++ or Objective-C++ program.
	-	<b>Extended</b> with new data types or operations through class derivation.
-	<b>Unicode-correct</b>: any <a href="http://www.utf8everywhere.org">UTF-8</a> text (without byte-order marker) defines a valid %Om program.

%Om is <b><em>not</em></b>:
-	<b>Complete</b>.  Although the intent is to develop %Om into a full-featured language, the software is currently at a very early "proof of concept" stage, requiring the addition of many operations (such as basic number and file operations) and optimizations before it can be considered useful for any real-world purpose.  It has been made available in order to demonstrate the underlying concepts and welcome others to get involved in early development.
-	<b>Stationary</b>.  %Om will likely undergo significant changes on its way to version 1.0.

\page background Background

The following reading may help explain some of the concepts that contributed to %Om:
-	<a href="http://evincarofautumn.blogspot.ca/2012/02/why-concatenative-programming-matters.html">Why Concatenative Programming Matters</a>
-	The Concatenative <a href="http://concatenative.org">wiki</a>, <a href="http://tech.groups.yahoo.com/group/concatenative">mailing list</a>, and <a href="http://en.wikipedia.org/wiki/Concatenative_programming_language">Wikipedia entry</a>
-	A <a href="http://www.kevinalbrecht.com/code/joy-mirror">mirror</a> of Manfred von Thun's original pages on the groundbreaking Joy Programming Language (<a href="http://en.wikipedia.org/wiki/Joy_(programming_language)">Wikipedia entry</a>), the father of all concatenative languages

\page syntax Syntax

\section syntax__program Program

An %Om <b>program</b> is a combination of three elements&mdash;operator, separator, and operand&mdash;as follows:

\image html "program.png"

\section syntax__operator Operator

An <b>operator</b> has the following syntax:

\image html "operator.png"

Backquotes (<tt>`</tt>) in operators are disregarded if the code point following is not a backquote, operand brace, or separator code point.

\section syntax__separator Separator

A <b>separator</b> has the following syntax:

\image html "separator.png"

\section syntax__operand Operand

An <b>operand</b> has the following syntax:

\image html "operand.png"

\page evaluation Evaluation

\section evaluation__functions Functions

Each program evaluates to a function.

A function takes a program as input and returns a program as output.

A function pulls elements from the front of the input program and pushes elements to the back of the output program.  Only <em>terms</em> (operators and operands) are significant to functions; separators are discarded from input, and are inserted between output terms in a "normalized" form (for consistent formatting and proper operator separation).  Therefore, only input and output terms are relevant in describing a function.

There are three fundamental types of functions:
-	<b>Identity</b>: Pushes all input terms onto the output program.
-	<b>Constant</b>: Pushes a term defined by the function, followed by all input terms, onto the output program.
-	<b>Operation</b>: Processes the input terms as follows:
	-	<b>Operand</b>: Processes the operand as data for a computation, defined by the operation, and pushes any terms generated by the computation onto the output program.  When the computation is "complete", any additional operands are pushed onto the output program, unchanged.
	-	<b>Operator</b>: Pushes the operator, followed by all remaining input terms, onto the output program.

\section evaluation__programs Programs

\subsection evaluation__programs__empty Empty Program

The empty program evaluates to the identity function.

\subsection evaluation__programs__single Single-Element Programs

Programs that contain only a single element evaluate to functions as follows:
-	<b>Separator</b>: Evaluates to the identity function.
-	<b>Operand</b>: Evaluates to a constant function that pushes the operand, followed by all input terms, onto the output program.
-	<b>Operator</b>: Evaluates to the operation defined for the operator in the environment; if none, evaluates to a constant function that pushes the operator, followed by all input terms, onto the output program.

\subsection evaluation__programs__multiple Multiple-Element Programs

Programs that contain multiple elements can be considered a concatenation of sub-programs that each contain one of the elements.  The concatenated program thus evaluates to the composition of the functions that each sub-program evaluates to.

For example, program "A B" is the concatenation of programs "A", " ", and "B".  The separator evaluates to the identity operation and can be disregarded.  The programs "A" and "B" evaluate to functions which will be denoted as <tt>A</tt> and <tt>B</tt>, respectively.  The input and output are handled by the composed function as follows:
-	Function <tt>B</tt> receives the input, and sends its output to function <tt>A</tt>.
-	Function <tt>A</tt> receives the input, and its output becomes that of the composed function.

Any programs may be concatenated together; however, note that concatenating programs "A" and "B" without an intervening separator would result in a program containing a single operator "AB", which is unrelated to operators "A" or "B".

\section evaluation__operations Operations

All operation implementations provided are documented in the \ref operations module.

\section evaluation__data_types Data Types

%Om uses a unique <em>panmorphic</em> type system in which all data values are represented within the language solely through a common program interface (comprised of only separators, operators, and/or operands).  Any operation will accept any operand as a valid input and interpret it however the operation deems appropriate.

There are no traditional data types in the language; data types are relegated to an implementation layer and represent optimizations for a set of operations.  Each operand in memory contains a single program implementation; by default, this is the \ref literal program, which preserves all data in the operand, verbatim (including separators).  However, an operation may prefer an operand to have a different program implementation that is optimized for specific functionality used by the operation.  The \ref find_operation operation, for example, prefers one of its operands to have a \ref lexicon program type for fast mapping from operator to operand.  In such cases, an operation can simply convert an undesired program implementation to the desired type through the common program interface without impacting the semantics of the program.

Operations in a program can be ordered by the programmer to increase performance by minimizing conversions between program implementations, but it is not necessary for obtaining a correct computation.  Data types in %Om therefore become an optimization-phase implementation detail.

All program implementations provided are documented in the \ref programs module.

\section evaluation__evaluator Evaluator

The evaluator reads, parses and evaluates the input stream in a single pass, sending results to the output stream as soon as they can be evaluated.  This is possible because %Om uses prefix notation rather than the postfix notation typical of concatenative languages.  Prefix notation has the following advantages over postfix notation:
-	Stack underflows are impossible.
-	Operations can be optimized to only read into memory the data that is required; stack-based postfix languages have no knowledge of the operation to apply until the data is already in memory, on the stack.
-	Incoming data, such as events, become simple to handle at a language level: a program might evaluate to a function that acts as a state machine, processing any additional operands appended to the program and transitioning to a new state, ready to process new data.
-	An IDE can provide hints to the user about the data that is expected by an operation.

\page examples Examples

The following program contains a single operand:
-	<tt>{Hello, world!}</tt>
	<blockquote><tt>{Hello, world!}</tt></blockquote>

Operands can be dropped and copied via the \ref drop_operation and \ref copy_operation operations:
-	<tt>drop {A}{B}{C}</tt>
	<blockquote><tt>{B}{C}</tt></blockquote>
-	<tt>copy {A}{B}{C}</tt>
	<blockquote><tt>{A}{A}{B}{C}</tt></blockquote>
-	<tt>drop copy {A}</tt>
	<blockquote><tt>{A}</tt></blockquote>
-	<tt>copy copy {A}</tt>
	<blockquote><tt>{A}{A}{A}</tt></blockquote>

The \ref drop_operation operation can therefore be used for comments:
-	<tt>drop {This is a comment.} {This is not a comment.}</tt>
	<blockquote><tt>{This is not a comment.}</tt></blockquote>

The \ref choose_operation operation selects one of two operands, depending on whether a third is empty:
-	<tt>choose {It was empty.}{It was non-empty.}{I am not empty.}</tt>
	<blockquote><tt>{It was non-empty.}</tt></blockquote>
-	<tt>choose {It was empty.}{It was non-empty.}{}</tt>
	<blockquote><tt>{It was empty.}</tt></blockquote>

An operation without sufficient operands evaluates to itself and whatever operands are provided:
-	<tt>drop</tt>
	<blockquote><tt>drop</tt></blockquote>
-	<tt>choose {It was empty.}{It was non-empty.}</tt>
	<blockquote><tt>choose{It was empty.}{It was non-empty.}</tt></blockquote>

The \ref quote_operation and \ref dequote_operation operations add and remove a layer of operand braces, respectively:
-	<tt>quote {B}</tt>
	<blockquote><tt>{{B}}</tt></blockquote>
-	<tt>dequote {{B}}</tt>
	<blockquote><tt>{B}</tt></blockquote>
-	<tt>dequote {copy}</tt>
	<blockquote><tt>copy</tt></blockquote>
-	<tt>dequote {copy} {A}</tt>
	<blockquote><tt>{A}{A}</tt></blockquote>

Operands can be popped from and pushed into:
-	<tt>&lt;-characters {ABC}</tt>
	<blockquote><tt>{A}{BC}</tt></blockquote>
-	<tt>-&gt;literal {A}{BC}</tt>
	<blockquote><tt>{ABC}</tt></blockquote>
-	<tt>&lt;-terms {some terms}</tt>
	<blockquote><tt>{some}{terms}</tt></blockquote>

A new operator definition can be provided with the \ref define_operation operation, where the first operand is treated as containing a \ref lexicon with operator-to-operand mappings, and the second operand contains the program to evaluate using the defined operator:
-	<tt>define { double-quote {quote quote} } { double-quote {A} }</tt>
	<blockquote><tt>{{{A}}}</tt></blockquote>

Any string can be used as an operator, with separators and operand braces escaped with a backquote:
-	<tt>define { double` quote {quote quote} } { double` quote {A} }</tt>
	<blockquote><tt>{{{A}}}</tt></blockquote>
-	<tt>&lt;-terms { double` quote operator }</tt>
	<blockquote><tt>{double` quote}{operator}</tt></blockquote>

Unicode is fully supported:
-	<tt>&lt;-characters {한글}</tt>
	<blockquote><tt>{한}{글}</tt></blockquote>
-	<tt>&lt;-code` points {한글}</tt>
	<blockquote><tt>{ᄒ}{ᅡᆫ글}</tt></blockquote>
-	<tt>&lt;-terms {한글 韓}</tt>
	<blockquote><tt>{한글}{韓}</tt></blockquote>

Strings are automatically <a href="http://unicode.org/reports/tr15">normalized</a> to <a href="http://unicode.org/reports/tr15/#Norm_Forms">NFD</a>, but can be explicitly normalized to <a href="http://unicode.org/reports/tr15/#Norm_Forms">NFKD</a> using the \ref normalize_operation operation:
-	<tt>normalize {2⁵}</tt>
	<blockquote><tt>{25}</tt></blockquote>

Recursion is very efficient in %Om, due to (a) the "eager" evaluation model enabled by prefix concatenative syntax (i.e. data is consumed immediately rather than being left on a stack), and (b) the non-recursive evaluation implementation in the evaluator that minimizes memory overhead of recursive calls and prevents stack overflow.   The following example uses recursion to give the minutes in a colon-delimited 24-hour time string:
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ minutes {1:23} }<br/>
	</tt>
	<blockquote><tt>{23}</tt></blockquote>

Each step of an evaluation can be represented as a program.  The following is the above program broken down into evaluation steps, where the code that is about to be replaced is <b>bold</b>, and the latest replacement is <em>italicized</em>:
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <b>minutes</b> {1:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <em>dequote choose {minutes} {} = {:} &lt;-characters</em> {1:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} = {:} <b>&lt;-characters {1:23}</b> }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} = {:} <em>{1} {:23}</em> }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} <b>= {:} {1}</b> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} <em>{}</em> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote <b>choose {minutes} {} {}</b> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote <em>{minutes}</em> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <b>dequote {minutes}</b> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <em>minutes</em> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <b>minutes</b> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <em>dequote choose {minutes} {} = {:} &lt;-characters</em> {:23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} = {:} <b>&lt;-characters {:23}</b> }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} = {:} <em>{:} {23}</em> }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} <b>= {:} {:}</b> {23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote choose {minutes} {} <em>{{:}}</em> {23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote <b>choose {minutes} {} {{:}}</b> {23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ dequote <em>{}</em> {23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ <b>dequote {}</b> {23} }<br/>
	</tt>
-	<tt>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ {23} }<br/>
	</tt>
-	<tt><b>define<br/>
	{ minutes { dequote choose {minutes} {} = {:} &lt;-characters } }<br/>
	{ {23} }</b><br/>
	</tt>
-	<tt><em>{23}</em></tt>

\page downloading Downloading

Code can be downloaded from the <a href="https://github.com/sparist/Om">Om GitHub repository</a>.
-	<b>Current version</b>:
	<a href="https://github.com/sparist/Om">main page</a>
-	<b>Released versions</b>:
	<a href="https://github.com/sparist/Om/tags">Tags page</a>

\page building Building

\section building__targets Targets

%Om project files are generated using <a href="http://cmake.org">CMake</a> and contain the following targets:
-	<b>%Om</b>: builds the interpreter project into <tt>products/</tt><em>platform</em>.
-	<b>%Om Documentation</b>: builds the documentation into <tt>products/doxygen</tt>.  Open <tt>html/index.html</tt> to view the HTML documentation in a browser.

\section building__platforms Platforms

Although it should be possible to build the code on any mainstream platform, it has only been built and tested on:
-	\ref building__platforms__xcode 4.5.2 on Mac OS X 10.8.2 (Mountain Lion)
-	\ref building__platforms__visual_studio 2010 Express on Windows Vista

\subsection building__platforms__xcode Xcode

Building in Xcode requires:
-	<a href="http://itunes.apple.com/us/app/xcode/id497799835?ls=1&mt=12">Xcode</a>
-	<a href="http://doxygen.org">Doxygen</a> and <a href="http://www.macports.org/ports.php?by=name&substr=graphviz">Graphviz (via MacPorts)</a>

To generate the <tt>Om.xcodeproj</tt> file (in <tt>products/xcode</tt>):
-	Ensure that Doxygen and Graphviz are installed, and in the path variable visible to applications.  <a href="http://overwatering.org/blog/2012-2013/08/setting-path-osx-mountain-lion">This article</a> explains how to do so.
-	Clone the Git repository.
-	Run <tt>make.sh</tt> and pass it the following arguments (in order):
	- 	The ICU root directory path.  To create this directory, download and unpack the <a href="http://download.icu-project.org/files/icu4c/50.1.2/icu4c-50_1_1-src.tgz">ICU4C 50.1.2 code archive</a> from the <a href="http://site.icu-project.org/download">ICU download page</a>.
	-	The Boost root directory path.  To create this directory, download and unpack the <a href="http://sourceforge.net/projects/boost/files/boost/1.52.0/boost_1_52_0.tar.gz/download">Boost 1.52.0 code archive</a> from the <a href="http://www.boost.org/users/download">Boost download page</a>.
	-	<b>Optional:</b> The UnitTest++ root directory path.  If omitted, unit tests will be excluded from the build.  To create this directory, download and unpack the <a href="http://sourceforge.net/projects/unittest-cpp/files/latest/download?source=files">UnitTest++ 1.4 code archive</a> from the <a href="http://sourceforge.net/projects/unittest-cpp/files">UnitTest++ download page</a>.

To update the Xcode project to reflect changes to the code directory tree:
-	Run <tt>remake.sh</tt>.

To remove the directory generated by <tt>make.sh</tt>:
-	Run <tt>unmake.sh</tt>.

\subsection building__platforms__visual_studio Visual Studio

Building in Visual Studio requires:
-	<a href="http://www.microsoft.com/visualstudio/eng/downloads">Visual Studio 2010</a>
-	<a href="http://msysgit.github.com">Git</a>
-	<a href="http://www.cmake.org">CMake</a>
-	<a href="http://doxygen.org">Doxygen</a> and
	<a href="http://graphviz.org">Graphviz</a>
-	<a href="http://subversion.tigris.org">Subversion</a> (if unit tests are to be included)

To generate the <tt>Om.sln</tt> file (in <tt>products/vs</tt>):
-	Ensure that Doxygen and Graphviz are installed, and in the path variable.
-	Clone the Git repository.
-	Run <tt>make.bat</tt> and pass it the following arguments (in order):
	- 	The ICU root directory path.  To create this directory, download and unpack the <a href="http://download.icu-project.org/files/icu4c/49.1.2/icu4c-49_1_2-src.zip">ICU4C 49.1.2 code archive</a> from the <a href="http://site.icu-project.org/download">ICU download page</a>.  (Note that ICU4C 50.1.1 cannot be used due to a <a href="https://svn.boost.org/trac/boost/ticket/7839">bug</a> that prevents building on Windows.)
	-	The Boost root directory path.  To create this directory, download and unpack the <a href="http://sourceforge.net/projects/boost/files/boost/1.52.0/boost_1_52_0.zip/download">Boost 1.52.0 code archive</a> from the <a href="http://www.boost.org/users/download">Boost download page</a>.
	-	<b>Optional:</b> The UnitTest++ root directory path.  If omitted, unit tests will be excluded from the build.  To create this directory, get the UnitTest++ 1.4 code via Subversion checkout (described on the <a href="https://sourceforge.net/projects/unittest-cpp/develop">UnitTest++ developer page</a>) and apply the patch attached to the <a href="https://sourceforge.net/tracker/?func=detail&aid=3583690&group_id=158151&atid=806686">Visual Studio 2010 support ticket</a>.  The UnitTest++ root directory is the <tt>UnitTest++</tt> subdirectory of the Subversion checkout directory.

To update the Visual Studio solution to reflect changes to the code directory tree:
-	Run <tt>remake.bat</tt>.

To remove the directory generated by <tt>make.bat</tt>:
-	Run <tt>unmake.bat</tt>.

\page using Using

The %Om interpreter takes input from the standard input stream, ending at the first unbalanced end brace, and sends output to the standard output stream.

%Om can be incorporated into any C++ or Objective-C++ project as follows:
-	Add the %Om <tt>code</tt> directory to the include path and include the desired files.  Inclusion of any operation files will automatically add the corresponding operation to the global system.
-	Link to the required <a href="http://icu-project.org">ICU (ICU4C 49.1.2)</a> and/or <a href="http://boost.org">Boost (1.51.0)</a> library dependencies.
-	Call the <tt>Om::System::Initialize</tt> function prior to use (eg. in the <tt>main</tt> function), passing in the desired UTF-8 locale (eg. "en_US.UTF-8").
-	Construct an <tt>Om::Environment</tt>, populate with any additional operator-program mappings, and call one of its <tt>Evaluate</tt> functions to evaluate a program.

\page contributing Contributing

There are several ways to contribute to the %Om project:
-	By \ref contributing__developing new \ref operations and \ref programs.
-	By \ref contributing__issue_reporting via bugs, patches, or enhancement requests.
-	By \ref contributing__funding further development of the %Om language.

\section contributing__developing Developing

%Om is written in modern, portable C++ and can be forked from the <a href="http://github.com/sparist/Om">%Om GitHub repository</a>.

<b>Note</b>: Because this is an early-stage project, there are not yet any compatibility guarantees between versions.

\subsection contributing__developing__coding_standard Coding Standard

All %Om development must adhere to the <a href="http://sparist.github.com/cpp_coding_standard.html">Sparist C++ Coding Standard</a>.

\subsection contributing__developing__adding_operations Adding Operations

Additional native functionality can be added to %Om by implementing new operations in C++.

There are two ways to implement an operation: as a composite operation, or an atomic operation.

To implement a composite operation, or an atomic operation that consumes no operands:
-	Define the operation <tt>struct</tt> in the <tt>Om::Operations</tt> namespace.
-	Define the static <tt>GetName()</tt> method, which returns a <tt>static char const *</tt> containing the name.
-	Define the static <tt>Give( Evaluation &amp; )</tt> method, with no return value, to give existing operations and/or elements to the evaluation.

To define an atomic operation that consumes one or more operands:
-	Define the operation <tt>struct</tt>, derived from <tt>Om::DefaultOperation&lt;</tt> <em>operation</em> <tt>&gt;</tt> (where <em>operation</em> is the name of the operation <tt>struct</tt>), in the <tt>Om::Operations</tt> namespace.
-	Define the static <tt>GetName()</tt> method, which returns a <tt>static char const *</tt> containing the name.
-	Add the implementation, using existing operations as a guide:
	-	Implement the functions necessary to compile.
	-	Optionally override virtual function implementations in <tt>DefaultOperation</tt>, such as <tt>ReadQuotedElements</tt>, that may be more optimally implemented in the operation.

For any operation implementation, code must be added to the operation header that inserts the operation into the system when the header is included, as follows (where <tt>WhateverOperation</tt> is a stand-in for the name of the operation <tt>struct</tt>):

\code
namespace
{
	static Definition< WhateverOperation > const theWhateverDefinition;
}
\endcode

\subsection contributing__developing__adding_programs Adding Programs

New data types can be added to %Om by extending <tt>Om::Program</tt> and defining the functions necessary to instantiate the class.  Use existing programs as a guide.

Program types should be defined in the <tt>Om</tt> namespace.

\subsection contributing__developing__analyzing_code Analyzing Code

Some basic free static analysis tools can be applied to the %Om code.

-	<a href="https://github.com/terryyin/hfcca"><b>HFCCA</b></a> is a Python script that measures cyclomatic complexity and counts the number of lines of code in C++ source files, not including comments or tests.  If Python is installed and in the path, HFCCA can be applied to %Om by entering the following at the terminal from inside the %Om directory:
	<blockquote><tt>python hfcca.py -p -v code</tt></blockquote>
-	<a href="http://cloc.sourceforge.net"><b>CLOC</b></a> is a stand-alone Perl script that determines total line counts.  If Perl is installed, CLOC can be applied to %Om by entering the following at the terminal from inside the %Om directory:
	<blockquote><tt>cloc.pl code</tt></blockquote>

\section contributing__issue_reporting Issue Reporting

Issues are reported and tracked with the <a href="https://github.com/sparist/Om/issues">Om GitHub issue tracker</a>.

Before reporting an issue, please search existing issues first to ensure that it is not a duplicate.

\section contributing__funding Funding

The %Om language is currently a spare-time project of <a href="http://sparist.com">one person</a>.  If you would like to speed the development of the %Om language in either a general or domain-specific direction, please contact me at <a href="mailto:information@sparist.com?subject=Om%20Funding">information@sparist.com</a>.

\page license License

This program and the accompanying materials are made available under the terms of the <a href="http://www.eclipse.org/legal/epl-v10.html">Eclipse Public License, Version 1.0</a>, which accompanies this distribution.

For more information about this license, please see the <a href="http://www.eclipse.org/legal/eplfaq.php">Eclipse Public License FAQ</a>.
*/
